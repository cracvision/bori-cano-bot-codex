// ttsHandler.jsw - 2025-06-23
/**
 * ttsHandler.jsw
 * M贸dulo de backend de Velo para generar audio a partir de texto usando la API de OpenAI (Text-to-Speech).
 * * Mejoras incluidas:
 * 1. Cach茅 de API Key: La clave se obtiene una sola vez para mejorar la eficiencia.
 * 2. Red de Seguridad (Fail-Safe): Un l铆mite de caracteres previene fallos si el texto es inesperadamente largo.
 * 3. L贸gica Simplificada: Se ha limpiado el c贸digo para mayor claridad y mantenibilidad.
 * 4. Manejo de Errores Robusto: Incluye un sistema de reintentos para las llamadas a la API.
 */

import { fetch } from 'wix-fetch';
import { getSecret } from 'wix-secrets-backend';

// --- Constantes de Configuraci贸n ---
const OPENAI_TTS_API_URL = "https://api.openai.com/v1/audio/speech";
const SAFETY_MAX_LENGTH = 1600; // L铆mite de caracteres como red de seguridad.

// --- 1. Cach茅 de la API Key ---
let openAIApiKey;

// Funci贸n para inicializar la API Key de forma segura. Se llama una vez cuando el m贸dulo se carga.
async function initializeApiKey() {
    if (openAIApiKey) return openAIApiKey;

    try {
        console.log(" ttsHandler.jsw: Obteniendo la API Key de OpenAI desde los secretos...");
        openAIApiKey = await getSecret("openai_api_key");
        if (!openAIApiKey) {
            console.error(" ttsHandler.jsw: API Key de OpenAI no encontrada en los secretos.");
        }
    } catch (error) {
        console.error(" ttsHandler.jsw: Error cr铆tico al obtener 'openai_api_key':", error);
        openAIApiKey = null; // Permite reintentar en la siguiente ejecuci贸n si falla.
    }
    return openAIApiKey;
}

// Inicia la obtenci贸n de la clave tan pronto como se carga el m贸dulo.
initializeApiKey();


// --- Funciones Auxiliares ---

// Limpia emojis y espacios extra de un texto.
function removeEmojis(text) {
    if (!text || typeof text !== 'string') return '';
    return text
        .replace(/[\p{Emoji_Presentation}\p{Emoji}\u200D\uFE0F]/gu, '')
        .replace(/\s+/g, ' ')
        .trim();
}

// Realiza una llamada fetch con una pol铆tica de reintentos.
async function fetchWithRetry(url, options, retries = 3, delay = 1000) {
    for (let i = 0; i < retries; i++) {
        try {
            const response = await fetch(url, options);
            console.log(` ttsHandler.jsw: Respuesta de API recibida. Status: ${response.status}`);
            return response;
        } catch (error) {
            console.error(` ttsHandler.jsw: Error en intento de fetch ${i + 1}:`, error);
            if (i === retries - 1) throw error;
            await new Promise(resolve => setTimeout(resolve, delay * (i + 1)));
        }
    }
    throw new Error("No se pudo conectar con la API de OpenAI tras varios intentos.");
}


// --- Funci贸n Principal Exportada ---

export async function generateAudio(text, language) {
    const textoLog = text && text.length > 100 ? text.substring(0, 97) + "..." : text;
    console.log(` ttsHandler.jsw: Proceso iniciado. Texto: "${textoLog}", Idioma: ${language}`);

    if (!text || typeof text !== 'string' || text.trim() === "") {
        console.error(" ttsHandler.jsw: El texto para generar audio est谩 vac铆o o es inv谩lido.");
        return { error: "Invalid or empty text" };
    }

    const apiKey = await initializeApiKey();
    if (!apiKey) {
        return { error: "API Key for OpenAI is not configured or could not be retrieved." };
    }

    // --- 2. L贸gica Simplificada para TTS ---
    const modeloTTS = "tts-1";
    const vozSeleccionada = "echo";
    const velocidadSeleccionada = 1.05;

    const textoLimpio = removeEmojis(text);
    if (!textoLimpio) {
        console.error(" ttsHandler.jsw: El texto qued贸 vac铆o despu茅s de limpiarlo.");
        return { error: "Empty text after cleaning" };
    }
    
    // --- 3. Aplicaci贸n de la Red de Seguridad ---
    let textoParaAudio = textoLimpio;
    if (textoLimpio.length > SAFETY_MAX_LENGTH) {
        console.warn(` ttsHandler.jsw: 隆ALERTA! El texto excede el l铆mite de seguridad de ${SAFETY_MAX_LENGTH} caracteres. La l贸gica principal del assistant deber铆a haberlo acortado. Se truncar谩 para evitar un fallo.`);
        textoParaAudio = textoLimpio.substring(0, SAFETY_MAX_LENGTH);
    }
    
    const requestBody = {
        model: modeloTTS,
        input: textoParaAudio,
        voice: vozSeleccionada,
        response_format: "mp3",
        speed: velocidadSeleccionada
    };

    const options = {
        method: "POST",
        headers: { "Authorization": `Bearer ${apiKey}`, "Content-Type": "application/json" },
        body: JSON.stringify(requestBody)
    };

    try {
        const response = await fetchWithRetry(OPENAI_TTS_API_URL, options);

        if (!response.ok) {
            const errorBody = await response.text();
            console.error(` ttsHandler.jsw: Respuesta no OK de la API: ${response.status} ${errorBody}`);
            return { error: `API Error: ${response.status}: ${errorBody}` };
        }

        // En el backend de Velo, .buffer() es el m茅todo directo y fiable.
        const nodeBuffer = await response.buffer();

        if (!nodeBuffer || nodeBuffer.length === 0) {
            console.error(" ttsHandler.jsw: El buffer de audio recibido est谩 vac铆o.");
            return { error: "Empty audio data received" };
        }

        const base64Audio = nodeBuffer.toString('base64');
        const dataUri = `data:audio/mp3;base64,${base64Audio}`;
        
        console.log(" ttsHandler.jsw: Audio generado y convertido a Data URI exitosamente.");
        return { audioUri: dataUri, language };

    } catch (error) {
        console.error(" ttsHandler.jsw: Error final en la generaci贸n de audio:", error.message || error);
        return { error: error.message };
    }
}