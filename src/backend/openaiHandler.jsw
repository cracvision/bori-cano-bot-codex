// backend/openaiHandler.jsw

import { fetch } from 'wix-fetch';
import { getSecret } from 'wix-secrets-backend';

// Allow dependency injection for unit tests.
let fetchFn = fetch;
let getSecretFn = getSecret;

export function __setTestDependencies({ fetch, getSecret } = {}) {
    if (fetch) fetchFn = fetch;
    if (getSecret) getSecretFn = getSecret;
    openAIApiKey = null; // reset cache for tests
}

// --- Constantes ---
const OPENAI_API_BASE_URL = "https://api.openai.com/v1";
const ASSISTANT_ID = "asst_CplVyaMXTSyXkNuqhmQJeDfh";

// --- Caché de la API Key ---
let openAIApiKey;

// Retrieve and cache the OpenAI secret on first use
async function initializeApiKey() {
    if (openAIApiKey) return openAIApiKey;
    try {
        console.log("🧠 openaiHandler.jsw: Obteniendo la API Key de OpenAI...");
        openAIApiKey = await getSecretFn("openai_api_key");
        if (!openAIApiKey) console.error("💥 openaiHandler.jsw: API Key de OpenAI no encontrada.");
    } catch (error) {
        console.error("💥 openaiHandler.jsw: Error crítico al obtener 'openai_api_key':", error);
        openAIApiKey = null;
    }
    return openAIApiKey;
}

// --- Función de Reintentos Robusta ---
// Retries fetch calls with exponential backoff and jitter
async function fetchWithRetry(url, options, retries = 5, initialDelay = 500) {
    for (let i = 0; i < retries; i++) {
        try {
            const response = await fetchFn(url, options);
            if (response.status >= 500) {
                throw new Error(`Error del servidor (Status ${response.status}), reintentando...`);
            }
            return response;
        } catch (error) {
            console.error(`💥 openaiHandler.jsw: Error en fetch (intento ${i + 1}):`, error.message);
            if (i === retries - 1) throw error;
            const exponentialBackoff = Math.pow(2, i) * initialDelay;
            const jitter = exponentialBackoff * 0.2 * Math.random();
            const delay = exponentialBackoff + jitter;
            await new Promise(resolve => setTimeout(resolve, delay));
        }
    }
}

// --- Funciones Auxiliares de Texto ---
// Clean response text for TTS and remove citation markers
function cleanTextForTTS(text) {
    if (typeof text !== 'string') return '';
    return text.replace(/[\u{1F300}-\u{1F9FF}\u{2600}-\u{26FF}\u{2700}-\u{27BF}]/gu, '').replace(/\s+/g, ' ').trim();
}

function removeCitations(text) {
    if (typeof text !== 'string') return text;
    return text.replace(/【\d+:\w+†[^\]]+】/g, '');
}

// --- ARQUITECTURA ASÍNCRONA ---

// --- FUNCIÓN #1: Iniciar el Run del Asistente ---
export async function startAssistantRun(userMessage, currentThreadId) {
    console.log(`🧠 Iniciando Run. UserMsg: "${userMessage.substring(0, 50)}...", ThreadID: ${currentThreadId}`);
    
    const apiKey = await initializeApiKey();
    if (!apiKey) return { error: "OpenAI API Key not configured." };

    // Common headers for OpenAI Assistant API
    const headers = {
        "Authorization": `Bearer ${apiKey}`,
        "Content-Type": "application/json",
        "OpenAI-Beta": "assistants=v2"
    };

    let threadIdToUse = currentThreadId;

    try {
        if (!threadIdToUse) {
            console.log("🧠 Creando nuevo Thread...");
            const threadResponse = await fetchWithRetry(`${OPENAI_API_BASE_URL}/threads`, { method: "POST", headers });
            if (!threadResponse.ok) throw new Error(`Error creando thread: ${await threadResponse.text()}`);
            threadIdToUse = (await threadResponse.json()).id;
        }

        const addMessageResponse = await fetchWithRetry(`${OPENAI_API_BASE_URL}/threads/${threadIdToUse}/messages`, {
            method: "POST",
            headers,
            body: JSON.stringify({ role: "user", content: userMessage })
        });
        if (!addMessageResponse.ok) throw new Error(`Error añadiendo mensaje: ${await addMessageResponse.text()}`);

        const runResponse = await fetchWithRetry(`${OPENAI_API_BASE_URL}/threads/${threadIdToUse}/runs`, {
            method: "POST",
            headers,
            body: JSON.stringify({ assistant_id: ASSISTANT_ID })
        });
        if (!runResponse.ok) throw new Error(`Error creando run: ${await runResponse.text()}`);
        
        const runData = await runResponse.json();
        
        return { threadId: threadIdToUse, runId: runData.id };

    } catch (error) {
        console.error(error);
        throw error;
    }
}

// --- FUNCIÓN #2: Verificar el Estado y Obtener el Resultado del Run ---
export async function getAssistantRunResult(threadId, runId, language = 'en', sessionState = {}) {
    // Polls the run status and fetches the last assistant message when done.
    const apiKey = await initializeApiKey();
    if (!apiKey) return { error: "OpenAI API Key not configured." };

    const headers = {
        "Authorization": `Bearer ${apiKey}`,
        "Content-Type": "application/json",
        "OpenAI-Beta": "assistants=v2"
    };

    try {
        // Usamos fetch normal aquí porque el bucle de polling ya está en el frontend
        const statusResponse = await fetchFn(`${OPENAI_API_BASE_URL}/threads/${threadId}/runs/${runId}`, { headers });
        if (!statusResponse.ok) throw new Error(`Error obteniendo estado del run: ${await statusResponse.text()}`);
        
        const statusData = await statusResponse.json();
        
        if (statusData.status === 'completed') {
            const messagesResponse = await fetchFn(`${OPENAI_API_BASE_URL}/threads/${threadId}/messages?order=desc&limit=1`, { headers });
            if (!messagesResponse.ok) throw new Error(`Error listando mensajes: ${await messagesResponse.text()}`);
            
            const messagesData = await messagesResponse.json();
            let botResponseText = "No se pudo obtener una respuesta.";
            if (messagesData.data && messagesData.data.length > 0) {
                 if(messagesData.data[0].content[0] && messagesData.data[0].content[0].type === 'text'){
                    botResponseText = messagesData.data[0].content[0].text.value;
                 }
            }

            botResponseText = removeCitations(botResponseText);

            // --- Extract or generate Google Maps link ---
            let mapsLink = '';
            const linkRegex = /(https?:\/\/(?:www\.)?(?:maps\.app\.goo\.gl|google\.[^\s]+\/maps[^\s]*))/i;
            const linkMatch = botResponseText.match(linkRegex);
            if (linkMatch) {
                mapsLink = linkMatch[1];
                botResponseText = botResponseText.replace(linkMatch[0], '').trim();
            } else {
                const coordMatch = botResponseText.match(/(-?\d{1,2}(?:\.\d+)?)[,\s]+(-?\d{1,3}(?:\.\d+)?)/);
                if (coordMatch) {
                    const lat = coordMatch[1];
                    const lng = coordMatch[2];
                    mapsLink = `https://www.google.com/maps/search/?api=1&query=${lat},${lng}`;
                } else {
                    const placeRegex = /(?:recomiendo|recomendar|visita|visit|checkout|ve a|dir[íi]gete a)\s+([^\.\n]+)/i;
                    const placeMatch = botResponseText.match(placeRegex);
                    if (placeMatch) {
                        const place = placeMatch[1].trim();
                        if (place) {
                            mapsLink = `https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(place)}`;
                        }
                    }
                }
            }

            if (mapsLink) {
                const lastLink = sessionState.lastOfferedLink || sessionState.lastMapLink;
                if (sessionState.includeMapLink && sessionState.awaitingMapConfirmation === mapsLink) {
                    botResponseText += `\n\n\ud83d\udccd ${mapsLink}`;
                    sessionState.lastOfferedLink = mapsLink;
                    sessionState.awaitingMapConfirmation = null;
                    sessionState.includeMapLink = false;
                } else if (lastLink !== mapsLink) {
                    botResponseText += `\n\nWould you like the Google Maps link?`;
                    sessionState.awaitingMapConfirmation = mapsLink;
                    sessionState.lastOfferedLink = mapsLink;
                    sessionState.includeMapLink = false;
                }
            } else {
                sessionState.awaitingMapConfirmation = null;
            }

            let languageForTTS = botResponseText.toLowerCase().includes("wepa") || botResponseText.match(/[áéíóúñ¿¡]/) ? 'es' : 'en';

            const cleanedForTTS = cleanTextForTTS(botResponseText.replace(/https?:\/\/\S+/g, '').replace(/(-?\d{1,2}(?:\.\d+)?)[,\s]+(-?\d{1,3}(?:\.\d+)?)/g, ''));

            return {
                status: 'completed',
                botResponseText: botResponseText,
                cleanedTextForTTS: cleanedForTTS,
                languageForTTS: languageForTTS,
                awaitingMapConfirmation: sessionState.awaitingMapConfirmation || null,
                lastMapLink: sessionState.lastOfferedLink || null
            };
        } else if (['failed', 'cancelled', 'expired'].includes(statusData.status)) {
             console.error(`💥 Run fallido con estado: ${statusData.status}`);
             throw new Error(`Run failed with status: ${statusData.status}`);
        } else {
            return { status: statusData.status }; // Sigue en progreso
        }

    } catch (error) {
        console.error(error);
        throw error;
    }
}