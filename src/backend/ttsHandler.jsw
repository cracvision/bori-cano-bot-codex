// ttsHandler.jsw - 2025-06-23
/**
 * ttsHandler.jsw
 * Módulo de backend de Velo para generar audio a partir de texto usando la API de OpenAI (Text-to-Speech).
 * * Mejoras incluidas:
 * 1. Caché de API Key: La clave se obtiene una sola vez para mejorar la eficiencia.
 * 2. Red de Seguridad (Fail-Safe): Un límite de caracteres previene fallos si el texto es inesperadamente largo.
 * 3. Lógica Simplificada: Se ha limpiado el código para mayor claridad y mantenibilidad.
 * 4. Manejo de Errores Robusto: Incluye un sistema de reintentos para las llamadas a la API.
 */

import { fetch } from 'wix-fetch';
import { getSecret } from 'wix-secrets-backend';

// --- Constantes de Configuración ---
const OPENAI_TTS_API_URL = "https://api.openai.com/v1/audio/speech";
const SAFETY_MAX_LENGTH = 1600; // Límite de caracteres como red de seguridad.

// --- 1. Caché de la API Key ---
let openAIApiKey;

// Función para inicializar la API Key de forma segura. Se llama una vez cuando el módulo se carga.
async function initializeApiKey() {
    if (openAIApiKey) return openAIApiKey;

    try {
        console.log("🔊 ttsHandler.jsw: Obteniendo la API Key de OpenAI desde los secretos...");
        openAIApiKey = await getSecret("openai_api_key");
        if (!openAIApiKey) {
            console.error("💥 ttsHandler.jsw: API Key de OpenAI no encontrada en los secretos.");
        }
    } catch (error) {
        console.error("💥 ttsHandler.jsw: Error crítico al obtener 'openai_api_key':", error);
        openAIApiKey = null; // Permite reintentar en la siguiente ejecución si falla.
    }
    return openAIApiKey;
}

// Inicia la obtención de la clave tan pronto como se carga el módulo.
initializeApiKey();


// --- Funciones Auxiliares ---

// Limpia emojis y espacios extra de un texto.
function removeEmojis(text) {
    if (!text || typeof text !== 'string') return '';
    return text
        .replace(/[\p{Emoji_Presentation}\p{Emoji}\u200D\uFE0F]/gu, '')
        .replace(/\s+/g, ' ')
        .trim();
}

// Realiza una llamada fetch con una política de reintentos.
async function fetchWithRetry(url, options, retries = 3, delay = 1000) {
    for (let i = 0; i < retries; i++) {
        try {
            const response = await fetch(url, options);
            console.log(`🔊 ttsHandler.jsw: Respuesta de API recibida. Status: ${response.status}`);
            return response;
        } catch (error) {
            console.error(`💥 ttsHandler.jsw: Error en intento de fetch ${i + 1}:`, error);
            if (i === retries - 1) throw error;
            await new Promise(resolve => setTimeout(resolve, delay * (i + 1)));
        }
    }
    throw new Error("No se pudo conectar con la API de OpenAI tras varios intentos.");
}


// --- Función Principal Exportada ---

export async function generateAudio(text, language) {
    const textoLog = text && text.length > 100 ? text.substring(0, 97) + "..." : text;
    console.log(`🔊 ttsHandler.jsw: Proceso iniciado. Texto: "${textoLog}", Idioma: ${language}`);

    if (!text || typeof text !== 'string' || text.trim() === "") {
        console.error("💥 ttsHandler.jsw: El texto para generar audio está vacío o es inválido.");
        return { error: "Invalid or empty text" };
    }

    const apiKey = await initializeApiKey();
    if (!apiKey) {
        return { error: "API Key for OpenAI is not configured or could not be retrieved." };
    }

    // --- 2. Lógica Simplificada para TTS ---
    const modeloTTS = "tts-1";
    const vozSeleccionada = "echo";
    const velocidadSeleccionada = 1.05;

    const textoLimpio = removeEmojis(text);
    if (!textoLimpio) {
        console.error("💥 ttsHandler.jsw: El texto quedó vacío después de limpiarlo.");
        return { error: "Empty text after cleaning" };
    }
    
    // --- 3. Aplicación de la Red de Seguridad ---
    let textoParaAudio = textoLimpio;
    if (textoLimpio.length > SAFETY_MAX_LENGTH) {
        console.warn(`🔊 ttsHandler.jsw: ¡ALERTA! El texto excede el límite de seguridad de ${SAFETY_MAX_LENGTH} caracteres. La lógica principal del assistant debería haberlo acortado. Se truncará para evitar un fallo.`);
        textoParaAudio = textoLimpio.substring(0, SAFETY_MAX_LENGTH);
    }
    
    const requestBody = {
        model: modeloTTS,
        input: textoParaAudio,
        voice: vozSeleccionada,
        response_format: "mp3",
        speed: velocidadSeleccionada
    };

    const options = {
        method: "POST",
        headers: { "Authorization": `Bearer ${apiKey}`, "Content-Type": "application/json" },
        body: JSON.stringify(requestBody)
    };

    try {
        const response = await fetchWithRetry(OPENAI_TTS_API_URL, options);

        if (!response.ok) {
            const errorBody = await response.text();
            console.error(`💥 ttsHandler.jsw: Respuesta no OK de la API: ${response.status} ${errorBody}`);
            return { error: `API Error: ${response.status}: ${errorBody}` };
        }

        // En el backend de Velo, .buffer() es el método directo y fiable.
        const nodeBuffer = await response.buffer();

        if (!nodeBuffer || nodeBuffer.length === 0) {
            console.error("💥 ttsHandler.jsw: El buffer de audio recibido está vacío.");
            return { error: "Empty audio data received" };
        }

        const base64Audio = nodeBuffer.toString('base64');
        const dataUri = `data:audio/mp3;base64,${base64Audio}`;
        
        console.log("🔊 ttsHandler.jsw: Audio generado y convertido a Data URI exitosamente.");
        return { audioUri: dataUri, language };

    } catch (error) {
        console.error("💥 ttsHandler.jsw: Error final en la generación de audio:", error.message || error);
        return { error: error.message };
    }
}